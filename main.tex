\documentclass{llncs}
%\documentclass[10pt, conference, compsocconf]{IEEEtran}

% From ESORICS'13 CFP
% Submitted papers should be at most 16 pages (using 10-point font), excluding 
% the bibliography and well-marked appendices, and at most 20 pages total.

\usepackage{listings}
\usepackage{url}

\usepackage{amssymb}
\usepackage[usenames]{color}
\definecolor{lightred}{rgb}{1,0.8,0.8}
\newcommand{\todo}[1]{\colorbox{red}{\textcolor{white}{\sffamily\bfseries\scriptsize TODO}} \textcolor{red}{#1} \textcolor{red}{$\blacktriangleleft$}}


\title{Architectures for Inlining Security Monitors in Web Applications}

\author{Jonas Magazinius \and Daniel Hedin \and Andrei Sabelfeld}
\institute{Chalmers University of Technology, Gothenburg, Sweden}
%%%%%%%%%%%%%%%% Schedule %%%%%%%%%%%%%%%%%%%%%%%%
\if 0
March 28 - paper shipped
March 27 - final polish
MArch 22 - intro and conclusions
March 20 - case studies + related work
March 17 - architecture and implementation done 
March 12 - implementation half-way
March 11 - architecture
\fi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}


\maketitle



\begin{abstract}
Securing JavaScript in the browser is an open and challenging
problem. Code from pervasive third-party JavaScript libraries exacerbates the
problem because it is executed with the same privileges as the code
that uses the libraries.
%
This paper focuses on securing JavaScript code by \emph{inlining}
security checks in the code before it is executed. We present
architectures for inlining security monitors for JavaScript: in
the browser, as an HTTP proxy, and as a web proxy (service). 
%
\todo{Jonas: The use of HTTP proxy/web proxy/suffix proxy is still under consideration (by me), and we'll need to discuss and update this to reflect that.}
%
These architectures offer great flexibility: they are parametric in the monitor itself,
and they provide freedom in the choice of where the monitor is
injected, allowing to serve the interests of users, code developers, code
integrators, and network administrators.
%
A key ingredient to open up for such flexibility is security monitoring in the form of a
security monitor for JavaScript, written itself in JavaScript.
%
Our case studies demonstrate successful deployment of a JavaScript
information-flow monitor with all three architectures.
\end{abstract}


% \begin{IEEEkeywords}
% Web Security; Polyglot; Injection; Cross-domain.
% \end{IEEEkeywords}








% 1-2 pages
\section{Introduction}
\label{sec:intro}

\todo{Daniel: I assume that we give a description on IF and monitors for IF in general in this section}

When introducing reference monitoring, Anderson~\cite{Anderson:72}
identifies the following requirements:
\begin{itemize}
\item \emph{monitor integrity}: the monitor must be tamperproof,
\item \emph{complete mediation}: the monitor must be always invoked, and
\item \emph{soundness}: the monitor must enforce the desired
  security policy.
\end{itemize}
In addition, requirements of \emph{conservativeness} and
\emph{transparency} are often in place for reference monitors to
ensure that no new behaviors are added or removed by monitors when the
original program is secure in the first place.

This paper proceeds as follows. Section~



\paragraph{Shadowing}
\todo{Daniel: me must make sure to differentiate between the inlining ala older papers and the inlining we do here.}

Inline the monitor into the JavaScript code. Appealing idea, previous work for 
toy languages, but difficult in practice. Abandoned due to complexity with 
coercion in expressions.


A growing number of web pages provide not only content, but services to their
users. In order to provide the service the provider requires the user to
provide potentially sensitive information such as user credentials, and payment
information. For such pages it is in the interest of the user that the
sensitive information is only disclosed to the intended recipient.  Today, no
browsers offer such guarantees. However, modern browsers allow the
functionality of the browser to be enriched via \emph{extensions}. 


\paragraph{Third-party code integration}
%\label{sec:mash}

Describe mashups, difficulties in mashup security and information flows in mashups.

%4 pages 
\section{Architecture}
\label{sec:arch}

This section presents the different architectures for inlining
security monitors. We motivate each architecture by scenarios of
intended usage, describe the details of the architectures, report on
security considerations as well as the pros and cons for each choice.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Browser extension}

Many websites require the user to provide sensitive information, e.g., user
credentials, or payment information. It lies in the interest of the user to
ensure the security of the sensitive information.  Modern browsers allow for
the functionality of the browser to be enriched via \emph{extensions}. By
deploying the security monitor via a browser extension it is possible to enforce
properties not normally offered by browser.  Regardless of whether the user is
private or corporate browser extensions provides a simple installs once protect
always deployment method.


\paragraph{Description}

A browser extension is a program that is installed into the browser in order to
change or enrich the functionality of the browser.  The basic idea behind
deploying via an extension is to replace the JavaScript engine with the monitor
--- recall that we consider only monitors that function as interpreters.
%
This can be achieved by turning off the standard JavaScript engine, and have
the extension traverse the page when loaded and execute the JavaScript scripts
using the monitor. 
%
Given that the monitor is written in the language used to implement the extensions
embedding the monitor in an extension is a simple matter; for most browser
the implementation language of extensions is JavaScript.

This method was pioneered by Zaphod~\cite{Zaphod}, a
FireFox extension, that replaces the standard JavaScript engine with the
experimental Narcissus engine.

\paragraph{Security considerations}

The integrity of the method is guaranteed by virtue of the fact that the
JavaScript engine is turned off and all scripts are interpreted by the monitor.
Hence, the scripts are not active; rather, they are passed as data to the
monitor, and are only able to influence the execution environment implemented
by the monitor and not the general execution environment of the monitor itself.

Further, complete mediation and soundness are inherited from the monitor, since
all executed scripts are executed by the monitor.


As described above browser extension are installed into the browser. In order
to be able to enrich the functionality of the browser the extensions run with
the same privileges as the browser. This entails that the monitor will be
running with elevated privileges.  Compared to the other methods of deployment
this means that a faulty monitor not only jeopardizes the property enforced by
the monitor, but might jeopardize the integrity of the entire browser.

\paragraph{Pros and cons}

The main benefit of the approach is that the extension gives the user direct
control over what security policies to enforce on the browsed pages. For
instance, it is possible to have any security violations reported to the user,
who can easily decide to allow or decline the violation. 

Whether the requirements of conservativeness, and transparency can be met
depends on when the scripts are executed and that all functionality provided by
the browser can be implemented by the monitor.

Consider first the execution time of scripts. When web pages are loaded, the
scripts of the pages are executed as they are encountered while parsing the web
page. This means that the DOM tree of the page might not have been fully
constructed when the scripts execute.  For scripts that interact with the DOM
tree this is important, in particular if the script injects nodes into the
tree. From a conservativeness and transparency perspective it is not entirely
satisfactory to traverse the DOM tree of the page after it has been
constructed.  Rather, scripts need to be executes as soon as they are added to
the tree, which can be achieved using DOM mutation events.

Another obstacle for transparency is that for different reasons not all
functionality provided by the browser can be reproduced by the monitor. One
example of this is \emph{document.write}. The semantics of
\emph{document.write} is loosely specified saying that \emph{document.write}
writes into a string into the current position of the document.  Intuitively,
\emph{document.write} writes into the character stream that is fed to the HTML
parser, which, for obvious reason can have drastic effects on the parsing of
the page. For security reasons extensions are prohibited from calling
\emph{document.write}. Hence, when run via an extension the monitor cannot
easily provide the full functionality of \emph{document.write}. 

On the positive side features like \emph{innerHTML} can be handled with
relative ease. \emph{innerHTML} is a property on all DOM nodes which allows the
text representation of the node to be changed. Any change of the
\emph{innerHTML} property causes the content of the node to be changed by
parsing the changed property. For other deployment methods this means that the
value written to \emph{innerHTML} must be validated, and possibly changed
before the write is allowed to occur.  For the extension based deployment this
is not the case.  Since the standard JavaScript execution engine is turned off
it is safe to write to the \emph{innerHTML} property. The write will trigger
the parser to rebuild the content of the node, but no scripts will be executed.
Any occuring scripts can be dealt with in a manner analogous to the scripts on
a loading page.

Finally, since the extension is provided with the content of the page it is
entirely independent of the method of transport. Thus, unlike other methods of
deployment it is unimportant whether the page or any of its resources are
fetched using HTTP or HTTPS.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Web proxy}

\paragraph{Description}

\paragraph{Security considerations}

\paragraph{Pros and cons}

\todo{Discuss HTTPS}


%\begin{itemize}
%\item- Practically the same monitor as the plugin
%\item- Browser independent
%\item- Less intrusive to the browser, simple proxy setup
%\item- Less cumbersome to setup
%\item Server-side configuration? So far we have not discussed configuration.
%\item- General, every browsed page
%\end{itemize}

\todo{users or in a corporate environment}

\paragraph{Description}
A proxy specific to relaying HTTP requests is often referred to as a web proxy.
A web proxy is a convenient way to include the monitor in browsed pages without 
modifying the browser. The browser is configured to relay 
all requests through the proxy, and the proxy rewrites the responses to include 
the monitor. Modifying the response makes the method more 
intrusive to the HTML content, but less intrusive to the users browser. 
This approach is appealing both to individual users and to network 
administrators, who protect the interest of multiple users. The main benefits of 
a web proxy compared to a browser extension are that it is browser independent, requires 
minimal configuration to set up and does not intrude in the browser. However, there 
are certain drawbacks as well. 
%
\paragraph{Security considerations}As an example, any JavaScript code executed outside of the monitor can affect 
the monitor state. Therefore, in order to protect the integrity of the monitor, all 
script code in a page must be executed within the monitor. Whereas a 
browser extension captures execution of all scripts by replacing the JavaScript 
engine of the browser, a web proxy must identify all contexts in which JavaScript 
can be executed and rewrite them to direct execution to the monitor.
%
%The design of the monitor allows us to reuse the monitor code used in the 
%browser extension, with barely any modifications. The modifications required 
%are again related to execution contexts. 
This effort continues as the monitor executes. Various JavaScript features, such as 
\emph{document.write} and \emph{innerHTML}, allow an arbitrary string to be 
interpreted and rendered as HTML. Any scripts present in the string will be 
executed upon interpretation. The monitor must account for this and again rewrite 
the string to direct execution to the monitor.

\paragraph

\subsection{Suffix proxy (service)}
%\todo{Jonas: Just found out that the "service" we developed is actually a suffix proxy, which actually could have been implemented in a simpler way using .htaccess request rewriting. Also found a way to redirect all ports to a single port using iptables. Perfect solution.}
%\begin{itemize}
%\item What is a web proxy
%\item How can a web proxy help in distributing the monitor
%\item 
%\item Delivering the associated cookies?
%\item Same-origin policy in respect to different design choices
%\item More intrusive in HTML content, rewrite links and external references 
%\item Browser independent? Depends on the monitor
%\item Not intrusive to the browser
%\item Even less cumbersome to setup, browse to server URL
%\item Server-side and client-side configuration possible?
%\item Less general, only browsed pages
%\end{itemize}

\todo{user who want security}

\paragraph{Description}

\paragraph{Security considerations}

\paragraph{Pros and cons}

\todo{Discuss HTTPS}


A \emph{suffix proxy} is special kind of web proxy that makes use of DNS wildcards to 
relay requests, instead of the usual practice of configuring the browser.
To direct the request to the proxy, the domain name of the 
proxy is appended to the target domain. The suffix proxy is set up such
that all requests to any sub-domain of the proxy domain is directed to the proxy domain, 
e.g. in DNS terms \emph{*.proxy.domain $\Rightarrow$ proxy.domain}. Typically, the user navigates to a 
web application associated with the proxy and enters the target URL in 
an input field. The web application appends the proxy domain and navigates the 
browser to the modified URL. As in the case of the web proxy, the suffix proxy 
relays the request to the target URL and the response is rewritten to include 
the monitor.

There are several differences between a suffix proxy compared to a traditional 
web proxy. One beneficial difference is that it does not require any configuration and leaves the browser 
completely unchanged. Another difference is that the suffix proxy lets the user decide which pages to proxy on a 
per-domain basis, making it more general than a traditional proxy that covers 
all requests. To accomplish this the domain of the original URL is modified.
The consequence is twofold; the original URL and the modified URL are no longer 
considered the same origin, and the domain of the proxy needs to 
be inlined in all external requests. The first implies that all origin specific 
information associated with the original domain, e.g. cookies and local storage, 
are no longer associated with the modified domain, and vice versa. 
The latter implies that apart from rewriting scripts within a page, all URLs to 
external resources, i.e., to origins outside the scope of the original origin, 
must be rewritten to include the domain of the proxy. This ensures that all 
resources associated with the page are loaded through the proxy.



\subsection{Integrator}

%The mashup integrator includes the monitor and decides which JavaScript should 
%run within the monitor. (Don't mention sandbox.) You're done.
%\begin{itemize}
%\item- No setup
%\item- Not intrusive to the browser
%\item- Not general
%\item- Deliberately intrusive to HTML
%\item- Integrator configuration, no user control
%\item- Run independent part of the code outside the monitor, possible performance gains
%\end{itemize}

Today web pages make extensive use of libraries to extend the functionality of 
the web page. As the code is executed in the context of the web page, it can 
access the content of the page. This requires that the code integrator must 
trust the library not to abuse this privilege. To a developer, an appealing alternative 
is to run untrusted code monitored, while running trusted code outside of the 
monitor. This can be achieved including the monitor in the page and loading the 
third-party code through the suffix proxy. The suffix proxy will rewrite the 
response to direct execution of the library to the monitor. This can also result in performance 
gains compared to running all code monitored, since a monitor typically introduces 
a runtime overhead. Compared to the suffix proxy, integrator driven monitor 
inclusion is deliberately intrusive to the HTML code. Such specialized use of the suffix 
proxy allows a developer to specify precisely which code will be subject to 
monitoring, making the approach even more general. 

This developer centric approach gives the developer full control over the 
configuration of the monitor and the policies to enforce. To a user this 
approach is not intrusive to the browser, requires no setup or configuration, 
but also limits the users control. 


% 2-3 pages 
\section{Implementation}
\label{sec:impl}

%\todo{Daniel: may I suggest we replace the pros and cons with implementation challenges}
%Describe features and drawbacks with each implementation.
%For each deployment option, we describe how it is implemented and show how the integrity of the monitor
%and complete mediation are achieved.
This section details our implementations of the three architectures
from the previous section. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Browser extension}

Firefox extensions are written in JavaScript. S
DOMContentLoaded 
traversing the DOM tree 


Given that
the security monitor is wrttien
Monitors written in JavaScript can easily be embedded in extensions


The method works by turning off the standard execution engine for JavaScript
by disallowing JavaScript in the preferences and listening to the appropriate
page load event. Once the event is received the page is traversed and all
scripts are executed using the replacement engine, i.e., the monitor. This
method was pioneered by the Zaphod \cite{Zaphod} extension for Firefox.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Web proxy}

\begin{itemize}
\item Proxy implemented in NodeJS
%\item- rewrite all or nothing, problem with passing configuration to proxy
\item DOM parsing to find scripts, compared to regular expressions
\item difficult to identify all contexts (SVG, CSS and PDF can be rewritten, not flash)
\item rewriting of JavaScript
\end{itemize}

All modern browsers support the use of web proxies to relay requests.
The use of a web proxy allow all outgoing HTTP requests to be 
relayed through the proxy server. The web proxy will act as a middle-man and make 
the request on behalf of the client. In the process it can modify both the 
request and the response. 

As a monitor deployment method the opportunity to rewrite the response is 
of interest. \todo{Jonas: bla bla, extend}

As opposed to a browser extension, which replaces the JavaScript engine, the 
monitor is executed in the context of the page it is included in. Naturally 
this is the same execution context in which all scripts that bundled with the 
page are executed. To protect the integrity of the monitor, all inline and 
external scripts must be rewritten to ensure that it is instead executed within the 
monitored execution context.

In the web proxy different rewriting rules apply depending on whether the 
requested content is HTML or JavaScript. 

\paragraph{Rewriting HTML}
For HTML the web proxy has to  identify all occurences of inline JavaScript, 
both script-tags and inline event handlers.
Due to browsers error tolerant parsing of HTML-code, meaning that the browser will make a best-effort attempt to make sense of malformed fragments of HTML,
simple search and replace is not satisfactory. It would require the search algorithm to account for 
As an example it is not regular expressions 
Instead, a DOM-parser is utilized 
to parse the page to a DOM-tree. This implies that the web proxy will consume more resources, but allows for simple location of inline script code.
Because all instances of script code will reference the monitor, the monitor must be added as the first script to be executed.


\paragraph{Rewriting JavaScript}

\subsection{Suffix proxy (service)}

\begin{itemize}
%\item rewrite all or some, can pass configuration through cookie
\item piggybacking, wildcard DNS
\item SSL? wildcard certificates? features and drawbacks 
\item disable SOP, domain relaxing?
\item DOM parsing to find scripts, compared to regular expressions
\item difficult to identify all contexts (SVG, CSS and PDF can be rewritten, not flash)
\item non-standard ports by forwarding all ports to one
\end{itemize}


\paragraph{Additional rewriting of HTML}
Since the suffix proxy is referenced by a different domain name than the target 
domain, additional rewriting is required. Apart from the rewriting of inline 
scripts and event handlers done in the web proxy, the suffix proxy must 
identify and rewrite the domain of all references to external HTML and 
JavaScript resources. Failing to do so, will load script code outside the 
context of the monitor, which would compromise the integrity of the monitor.

The web proxy was implemented in Node.js. 

There are different technical approaches to communicate the target URL to the web 
proxy. The URL can either be sent as a parameter of the request, 

The features of wildcard certificates is that the user can browse HTTPS pages. The drawback is that the user must fully trust that the monitor correctly verifies the signature of the page.

\todo{same origin policy between pages from different original domains loaded through the monitor can be relaxed to the origin of the proxy and share information freely}



\subsection{Integrator}

\begin{itemize}
\item- rewrite some, integrator driven, no or limited user configuration
\item- no need for parsing, integrator decides
\item- well defined per site policy
\item- site could allow user to configure policy
\item- requires developer understanding of the monitor
\item- future reflection of monitored code?
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 2-3 pages 
\section{Instantiation}
\label{sec:case}

This section presents practical experiments made by instantiating the deployment
methods with the JSFlow~\cite{} information flow monitor. 

\subsection{Monitor}

JSFlow is a dynamic information flow monitor by tagging values with runtime
security labels used for security decisions. Whenever a potential security
violation has been encountered the monitor stops the execution with a security
error. 

JSFlow is implemented in JavaScript and supports full non-strict Ecma-262 (v5)
including the standard API and large parts of the browser specific execution
environment including the DOM.

The standard security policy of JSFlow tracks user information.  Any
information originating from the user is tagged and prevented from leaving the
browser. Other policies can be provided, e.g., by placing policy labels in the
HTML elements of the page. 


\subsection{Experiment scenarios}

Consider the scenario of a loan calculator service. To use the service the
user is required to input potentially sensitive information about income, 
loan amount, and loan term. The service then computes and displays, e.g., 
rate and monthly payment. Unless the calculation makes use of any trade secrets
it can be performed in its entirety on the client side; otherwise, the
user inputs must be sent back to the service provider that performs the
calculations and replies with the results. Even though it might be acceptable to 
the user to disclose the sensitive information the service provider,
doing so places a trust in the provider not to further disclose the information.

Below we investigate the different deployment methods on a calculator service
that sends information back to the service provider. In particular, we
investigate the loan and mortgage calculator \emph{mlcalc}. The user
information that is sent back to the server is, in turn, embedded in the return
page. There, the information is used to perform the loan calculation in
addition to being passed on to Google analytics, presumably for statistics. Now
assume that the user wants to prevent the information to be sent to Google.
Without server support there is no way for the JSFlow monitor to link the
values on the returned page to the values input by the user, regardless of
deployment method. On the other hand, if the server was information flow aware
it could tag the information originating from the user input on the returned
page. If this is done, the monitor can easily prevent the information from
being sent to Google analytics. Without server support, however, in order to
protect the user input we must prevent it from being sent back to mlcalc. 

\subsection{Security experiments}
%Jonas+Daniel

\todo{Daniel: what about the caches ets - where do we speak about those}
\paragraph{Browser extension}
%:
When the user loads mlcalc.com the extension traverses the page looking for
scripts to execute. After the scripts have executed the user of the page
enters the needed information and presses the calculate button. The extension
traps the button press event and uses the monitor to run the script associated
with the button. This script gathers the user information and tries to send
it back to mlcalc, which casues the montior to stop execution with a security 
error. At this point the user is presented with a security error message. 
Additionally, one could envision that the user is given the choice to
override the security error and allow the information to be sent.


\paragraph{Web proxy}

Jonas, fill in the web proxy results on mlcalc


\paragraph{Service}

Jonas, fill in the service results on mlcalc


\subsection{Performance experiments}
%Jonas

%1 page 
\section{Related work}
\label{sec:related}

Anderson~\cite{Anderson:72}

Erlingsson and Schneider~\cite{DBLP:conf/nspw/ErlingssonS99}

Language-based information-flow security encompasses a large body of
work, see an overview~\cite{Sabelfeld:Myers:JSAC}. We briefly
discuss inlining, followed by a consideration of most related work: on
formalizations of purely dynamic and hybrid monitors for information flow.

Inlined reference monitoring~\cite{Erlingsson:PhD04} is a mainstream
technique for enforcing safety properties. 
A prominent example in the context of the web is
BrowserShield~\cite{Reis+:TWeb07} that instruments scripts with
checks for known vulnerabilities.
The focus of this paper is on inlining for information-flow security. Information flow is not
a safety property~\cite{McLean:SSP94}, but can be approximated by
safety properties
(e.g.,~\cite{Boudol:FAST08,Sabelfeld:Russo:PSI09,Austin:Flanagan:PLAS09}),
just like it is approximated in this paper (see the remark at the end of Section~\ref{sec:intro}).

Chudnov and
Naumann~\cite{Chudnov:Naumann:CSF10} have investigated an inlining
approach to monitoring information flow. They inline a flow-sensitive
hybrid monitor by Russo and
Sabelfeld~\cite{Russo:Sabelfeld:CSF10}. The soundness of the inlined
monitor is ensured by bisimulation of the inlined monitor and the
original monitor.

Ligatti et al. \cite{Ligatti05editautomata:} present a 
general framework for security policies that can
be enforced by monitoring and modifying programs at runtime. 
They introduce \emph{edit automata} that enable
monitors to stop, suppress, and modify the behavior of programs. 

Magazinius et al.~\cite{DBLP:conf/nordsec/MagaziniusPS10}

Magazinius et al.~\cite{DBLP:journals/compsec/MagaziniusRS12}

Dam et al.~\cite{DBLP:conf/ecoop/DamJLP09,DBLP:journals/jcs/DamJLP10,DBLP:conf/ccs/DamGL12}

%1 page 
\section{Conclusions}
\label{sec:conc}

% Less than 4 pages 
\bibliographystyle{plain}
\bibliography{literature}
\end{document}
