\documentclass{llncs}
%\documentclass[10pt, conference, compsocconf]{IEEEtran}

% From ESORICS'13 CFP
% Submitted papers should be at most 16 pages (using 10-point font), excluding 
% the bibliography and well-marked appendices, and at most 20 pages total.

\usepackage{listings}
\usepackage{url}

\usepackage{amssymb}
\usepackage[usenames]{color}
\definecolor{lightred}{rgb}{1,0.8,0.8}
\newcommand{\todo}[1]{\colorbox{red}{\textcolor{white}{\sffamily\bfseries\scriptsize TODO}} \textcolor{red}{#1} \textcolor{red}{$\blacktriangleleft$}}


\title{Architectures for Inlining Information-Flow Monitors in Web Applications}

%%%%%%%%%%%%%%%% Schedule %%%%%%%%%%%%%%%%%%%%%%%%
\if 0
March 28 - paper shipped
March 27 - final polish
March 20 - mashup and case studies + intro and conclusions
March 13 - architecture and implementation done + related work
March 6 - most implementation done
\fi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}


\maketitle



\begin{abstract}
Various implementations of ways to distribute a monitor to the clients.
\end{abstract}


% \begin{IEEEkeywords}
% Web Security; Polyglot; Injection; Cross-domain.
% \end{IEEEkeywords}








% 1-2 pages
\section{Introduction}
\label{sec:intro}

\todo{Daniel: I assume that we give a description on IF and monitors for IF in general in this section}

% 1 pages
\section{Mashups}
\label{sec:mash}

Describe mashups, difficulties in mashup security and information flows in mashups.

% 2-3 pages 
\section{Architecture}
\label{sec:arch}

The fact that the monitor is written in JavaScript unlocks a number of
different deployment options. In particular it allows the monitor to be run as
as browser extension, or as a part of the web page itself.  In this section we
give an overview of the different available approaches, and discuss their
relative strengths.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Shadowing}
\todo{Daniel: me must make sure to differentiate between the inlining ala older papers and the inlining we do here.}

Inline the monitor into the JavaScript code. Appealing idea, previous work for 
toy languages, but difficult in practice. Abandoned due to complexity with 
coercion in expressions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo{Daniel: changed the name - plugins are things like Flash etc}
\subsection{Browser extension}
%
Modern browsers allow the functionality of the browser to be enriched via
\emph{extensions} typically written in JavaScript. This allows for the monitor
to be executed as part of an extension, which in turn allows for the use of the
monitor as the execution engine of web pages. The idea was pioneered by the
Zaphod\cite{Zaphod} extension for Firefox.  The basic idea is to turn of the
standard JavaScript interpreter by disallowing JavaScript in the preferences
and listen to the appropriate page load event. Once the event is received the
page is traversed and all scripts are executed using the replacement engine,
e.g., the monitor. 

The main benefit of extensions is that once installed the engine is changed for
all pages without further interaction needed from the user. However, this
installation requirement is also the method's main disadvantage. Not only does
it require the user to download, install and setup the extension, it also 
requires the user to trust the extension. In order to be able to enrich the 
functionality of the browser the extensions run with the same privileges as the
browser. By allowing the monitor to run as part of an extension we allow it to
run with elevated privileges. Thus, we must trust the
monitor not only to provide information flow control, but not allow for 
the interpreted code to exploit the privileges of the monitor. In the extension
scenario, a breach of the monitor puts more than the information flow control
at stake.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Proxy}

Proxy injects monitor into every page and wraps all JavaScript. Setup the proxy 
and you're done.
\begin{itemize}
\item- Practically the same monitor as the plugin
\item- Browser independent
\item- Less intrusive to the browser, simple proxy setup
\item- Less cumbersome to setup
\item- Server-side configuration
\item- General, every browsed page
\end{itemize}

\subsection{Service}

Service injects browsed pages with the monitor and references to itself, and 
wraps all JavaScript. Browse through service and you're done.
\begin{itemize}
\item- More intrusive in HTML content, rewrite links and external references 
\item- Browser independent
\item- Not intrusive to the browser
\item- Even less cumbersome to setup, browse to server URL
\item- Server-side and client-side configuration possible
\item- Less general, only browsed pages
\end{itemize}

\subsection{Integrator}

The mashup integrator includes the monitor and decides which JavaScript should 
run within the monitor. (Don't mention sandbox.) You're done.
\begin{itemize}
\item- No setup
\item- Not intrusive to the browser
\item- Not general
\item- Deliberately intrusive to HTML
\item- Integrator configuration, no user control
\item- Run independent part of the code outside the monitor, possible performance gains
\end{itemize}


% 4 pages 
\section{Implementation}
\label{sec:impl}

Describe features and drawbacks with each implementation.

% Implementation details

\subsection{Browser extension}

\begin{itemize}
\item- rewrite all or some, client-side configuration
\item- innerHTML
\item- difficult to mimic execution order in the page parsing
\item- document.write
\item- firefox challenges
\item- execution order (script inclusion heavy but possible)
\item- execution contexts no problem (SVG and CSS uses native JavaScript)
\end{itemize}

\subsection{HTTP Proxy}

\begin{itemize}
\item- Proxy implemented in NodeJS
\item- rewrite all or nothing, problem with passing configuration to proxy
\item- DOM parsing to find scripts, compared to regular expressions
\item- difficult to identify all contexts (SVG, CSS and PDF can be rewritten, not flash)
\end{itemize}



\subsection{Web proxy (Service)}

\begin{itemize}
\item- rewrite all or some, can pass configuration through cookie
\item- piggybacking, wildcard DNS compared to URL parameter
\item- disable SOP, domain relaxing
\item- DOM parsing to find scripts, compared to regular expressions
\item- difficult to identify all contexts (SVG, CSS and PDF can be rewritten, not flash)
\end{itemize}

The web proxy was implemented in Node.js. 

There are different technical approaches to communicate the target URL to the web 
proxy. The URL can either be sent as a parameter of the request, 

\subsection{Integrator}

\begin{itemize}
\item- rewrite some, integrator driven, no or limited user configuration
\item- no need for parsing, integrator decides
\item- well defined per site policy
\item- site could allow user to configure policy
\item- requires developer understanding of the monitor
\item- future reflection of monitored code?
\end{itemize}


% 2-3 pages 
\section{Case study}
\label{sec:case}

\begin{itemize}
\item- mlcalc.com
\item- newyorker.com
\item- mockup vs. real deal
\end{itemize}

%1 page 
\section{Related work}
\label{sec:related}

Inlining Erlingsson-Schneider 1990.

%1 page 
\section{Conclusions}
\label{sec:conc}

% Less than 4 pages 
\bibliographystyle{plain}
\bibliography{literature}
\end{document}
