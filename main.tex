\documentclass{llncs}
%\documentclass[10pt, conference, compsocconf]{IEEEtran}

% From ESORICS'13 CFP
% Submitted papers should be at most 16 pages (using 10-point font), excluding 
% the bibliography and well-marked appendices, and at most 20 pages total.

\usepackage{listings}
\usepackage{url}

\usepackage{amssymb}
\usepackage[usenames]{color}
\definecolor{lightred}{rgb}{1,0.8,0.8}
\newcommand{\todo}[1]{\colorbox{red}{\textcolor{white}{\sffamily\bfseries\scriptsize TODO}} \textcolor{red}{#1} \textcolor{red}{$\blacktriangleleft$}}


\title{Architectures for Inlining Security Monitors in Web Applications}

\author{Jonas Magazinius \and Daniel Hedin \and Andrei Sabelfeld}
\institute{Chalmers University of Technology, Gothenburg, Sweden}
%%%%%%%%%%%%%%%% Schedule %%%%%%%%%%%%%%%%%%%%%%%%
\if 0
March 28 - paper shipped
March 27 - final polish
March 20 - mashup and case studies + intro and conclusions
March 13 - architecture and implementation done + related work
March 12 - implementation half-way
March 11 - architecture
\fi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}


\maketitle



\begin{abstract}
Securing JavaScript in the browser is an open and challenging
problem. Code from pervasive third-party JavaScript libraries exacerbates the
problem because it is executed with the same privileges as the code
that uses the libraries.
%
This paper focuses on securing JavaScript code by \emph{inlining}
security checks in the code before it is executed. We present
architectures for inlining security monitors for JavaScript: in
the browser, as an HTTP proxy, and as a web proxy (service). 
%
\todo{Jonas: The use of HTTP proxy/web proxy/suffix proxy is still under consideration (by me), and we'll need to discuss and update this to reflect that.}
%
These architectures offer great flexibility: they are parametric in the monitor itself,
and they provide freedom in the choice of where the monitor is
injected, allowing to serve the interests of users, code developers, code
integrators, and network administrators.
%
A key ingredient to open up for such flexibility is security monitoring in the form of a
security monitor for JavaScript, written itself in JavaScript.
%
Our case studies demonstrate successful deployment of a JavaScript
information-flow monitor with all three architectures.
\end{abstract}


% \begin{IEEEkeywords}
% Web Security; Polyglot; Injection; Cross-domain.
% \end{IEEEkeywords}








% 1-2 pages
\section{Introduction}
\label{sec:intro}

\todo{Daniel: I assume that we give a description on IF and monitors for IF in general in this section}

When introducing reference monitoring, Anderson~\cite{Anderson:72}
identifies the following requirements:
\begin{itemize}
\item \emph{monitor integrity}: the monitor must be tamperproof,
\item \emph{complete mediation}: the monitor must be always invoked, and
\item \emph{soundness}: the monitor must enforce the desired
  security policy.
\end{itemize}
In addition, requirements of \emph{conservativeness} and
\emph{transparency} are often in place for reference monitors to
ensure that no new behaviors are added or removed by monitors when the
original program is secure in the first place.

This paper proceeds as follows. Section~


% 1 pages
\section{Third-party code integration}
\label{sec:mash}

Describe mashups, difficulties in mashup security and information flows in mashups.

% 2-3 pages 
\section{Architecture}
\label{sec:arch}

\todo{Daniel: may I suggest we add pros and cons}
This section presents the different architectures for inlining
security monitors. We motivate each architecture by scenarios of
intended usage and describe the details of the architectures.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Browser extension}

A growing number of web pages provide not only content, but services to their
users. In order to provide the service the provider requires the user to
provide potentially sensitive information such as user credentials, and payment
information. For such pages it is in the interest of the user that the
sensitive information is only disclosed to the intended recipient.  Today, no
browsers offer such guarantees. However, modern browsers allow the
functionality of the browser to be enriched via \emph{extensions}. 

By embedding the security monitor in an extension the browser can be modified
to provide such guarantees. The main benefit of this approach is that the
monitor provides guarantees for all pages. Further, this deployment method
gives the user direct control over what security policies to enforce on the
browsed pages.

\todo{Andrei: the following paragraph has two problems. First, it
  talks about information-flow control - but we want to stay general
  and only use information-flow control in examples. Second, of course
the monitor is a part of the TCB, which is true for all deployment
options. Why bring it up here?}
\todo{Daniel: Rewrote - why? There is a difference due to the elevated privilege; in the
  other cases a faulty monitor might leak inforamtion - in this case a faulty
  monitor might joepardize the computer}

However, the installation requirement is also the method's main disadvantage.
Not only is the extension browser specific and require the user to download,
install and setup the extension, it also requires that we trust the monitor to
run with elevated privileges --- in order to be able to enrich the
functionality of the browser the extensions run with the same privileges as the
browser. Compared to the other methods of deployment this means that a faulty
monitor not only jeopardizes the property enforced by the monitor, but might
jeopardize the integrity of the entire browser.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Web proxy}

\begin{itemize}
%\item- Practically the same monitor as the plugin
%\item- Browser independent
%\item- Less intrusive to the browser, simple proxy setup
%\item- Less cumbersome to setup
\item Server-side configuration? So far we have not discussed configuration.
%\item- General, every browsed page
\end{itemize}

A proxy specific to relaying HTTP requests is often referred to as a web proxy.
A web proxy is a convenient way to include the monitor in browsed pages without 
modifying the browser. The browser is configured to relay 
all requests through the proxy, and the proxy rewrites the responses to include 
the monitor. Modifying the response makes the method more 
intrusive to the HTML content, but less intrusive to the users browser. 
This approach is appealing both to individual users and to network 
administrators, who protect the interest of multiple users. The main benefits of 
a web proxy compared to a browser extension are that it is browser independent, requires 
minimal configuration to set up and does not intrude in the browser. However, there 
are certain drawbacks as well. 
%
As an example, any JavaScript code executed outside of the monitor can affect 
the monitor state. Therefore, in order to protect the integrity of the monitor, all 
script code in a page must be executed within the monitor. Whereas a 
browser extension captures execution of all scripts by replacing the JavaScript 
engine of the browser, a web proxy must identify all contexts in which JavaScript 
can be executed and rewrite them to direct execution to the monitor.
%
%The design of the monitor allows us to reuse the monitor code used in the 
%browser extension, with barely any modifications. The modifications required 
%are again related to execution contexts. 
This effort continues as the monitor executes. Various JavaScript features, such as 
\emph{document.write} and \emph{innerHTML}, allow an arbitrary string to be 
interpreted and rendered as HTML. Any scripts present in the string will be 
executed upon interpretation. The monitor must account for this and again rewrite 
the string to direct execution to the monitor.



\subsection{Suffix proxy}
\todo{Jonas: Just found out that the "service" we developed is actually a suffix proxy, which actually could have been implemented in a simpler way using .htaccess request rewriting. Also found a way to redirect all ports to a single port using iptables. Perfect solution.}
\begin{itemize}
%\item What is a web proxy
%\item How can a web proxy help in distributing the monitor
%\item 
%\item Delivering the associated cookies?
%\item Same-origin policy in respect to different design choices
%\item More intrusive in HTML content, rewrite links and external references 
%\item Browser independent? Depends on the monitor
%\item Not intrusive to the browser
%\item Even less cumbersome to setup, browse to server URL
\item Server-side and client-side configuration possible?
%\item Less general, only browsed pages
\end{itemize}


A \emph{suffix proxy} is special kind of web proxy that makes use of DNS wildcards to 
relay requests, instead of the usual practice of configuring the browser.
To direct the request to the proxy, the domain name of the 
proxy is appended to the target domain. The suffix proxy is set up such
that all requests to any sub-domain of the proxy domain is directed to the proxy domain, 
e.g. in DNS terms \emph{*.proxy.domain $\Rightarrow$ proxy.domain}. Typically, the user navigates to a 
web application associated with the proxy and enters the target URL in 
an input field. The web application appends the proxy domain and navigates the 
browser to the modified URL. As in the case of the web proxy, the suffix proxy 
relays the request to the target URL and the response is rewritten to include 
the monitor.

There are several differences between a suffix proxy compared to a traditional 
web proxy. A suffix proxy lets the user decide which pages to proxy on a 
per-domain basis, making it more general than a traditional proxy that covers 
all requests. To accomplish this the domain of the original URL is modified.
The consequence is twofold; the original URL and the modified URL are no longer 
considered the same origin, and the domain of the proxy needs to 
be inlined in all external requests. The first implies that all origin specific 
information associated with the original domain, e.g. cookies and local storage, 
are no longer associated with the modified domain, and vice versa. 
The latter implies that apart from rewriting scripts within a page, all URLs to 
external resources, i.e., to origins outside the scope of the original origin, 
must be rewritten to include the domain of the proxy. This ensures that all 
resources associated with the page are loaded through the proxy.

\todo{deal with this sentence}
Another benefit is that it does not require any configuration and leaves the browser 
completely unchanged.



\subsection{Integrator}

The mashup integrator includes the monitor and decides which JavaScript should 
run within the monitor. (Don't mention sandbox.) You're done.
\begin{itemize}
\item- No setup
\item- Not intrusive to the browser
\item- Not general
\item- Deliberately intrusive to HTML
\item- Integrator configuration, no user control
\item- Run independent part of the code outside the monitor, possible performance gains
\end{itemize}


% 4 pages 
\section{Implementation}
\label{sec:impl}

\todo{Daniel: may I suggest we replace the pros and cons with implementation challenges}
%Describe features and drawbacks with each implementation.
For each deployment option, we first describe how it is implemented,
discuss the relative pros and cons, and show how the integrity of the monitor
and complete mediation are achieved.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Browser extension}

Modern browsers allow the functionality of the browser to be enriched via
\emph{extensions}. The extensions are typically written in JavaScript.  
Monitors written in JavaScript can easily be embedded in extensions

\todo{Daniel: the rest of this section talks about monitors that are actually interpreters}

The method works by turning off the standard execution engine for JavaScript
by disallowing JavaScript in the preferences and listening to the appropriate
page load event. Once the event is received the page is traversed and all
scripts are executed using the replacement engine, i.e., the monitor. This
method was pioneered by the Zaphod \cite{Zaphod} extension for Firefox.

We have resolved a number of challenges pertaining to the implementation of the
extension.

\paragraph{Execution time}

When web pages are loaded, the scripts of the pages are executed as they are
encountered while parsing the web page. This means that the DOM tree of the
page might not have been fully constructed when the scripts execute.  For
scripts that interact with the DOM tree this is important, in particular if the
script injects nodes into the tree. The consequence of this is that it is not
entirely satisfactory to listen to the \emph{DOMContentLoaded} event and
thereafter traverse the fully parsed DOM tree looking for scripts to execute.
Rather, we need to receive events precisely when the scripts are added to the
DOM tree during the parsing process. This can be be achieved with DOM
MutationEvents. However, the DOM MutationEvents are deprecated due to
efficiency issues and are going to be replaced with a notion of
MutationObserver.  If the replacement notion can be used to execute scripts at
the time of addition to the DOM tree remains an open question due to event
grouping, i.e., when the mutation observer receives a collection of events
bundled together for performance reasons. 


\paragraph{document.write} The problem of execution time is particularly
prominent for scripts using \emph{document.write}. The semantics of
\emph{document.write} is loosely specified saying that \emph{document.write}
writes into a string into the current position of the document.  Intuitively,
\emph{document.write} writes into the character stream that is fed to the HTML
parser, which, for obvious reason can have drastic effects on the parsing of
the page.  However, in Firefox there is a bigger obstacle for
\emph{document.write}. For security reasons \emph{document.write} is not
allowed to be executed from the extension context.  Hence, an extension cannot
easily provide the full functionality of \emph{document.write}.  Thankfully,
few web pages make use of the full functionality of \emph{document.write} ---
it is mostly used to inject scripts into the page while the page is loading. It
is fairly easy to identify such use of \emph{document.write} and provide
support for this use.


\todo{Daniel: crosslink with other deployment methods?} \paragraph{innerHTML}
%
\emph{innerHTML} is a property on all DOM nodes which allows the text
representation of the node to be changed. Any change of the \emph{innerHTML}
property causes the content of the node to be changed by parsing the changed
property. For other deployment methods this means that the value written to
\emph{innerHTML} must be validated, and possibly changed before the write is
allowed to occur.  For the extension based deployment this is not the case.
Since the standard JavaScript execution engine is turned off it is safe to
write to the \emph{innerHTML} property. The write will trigger the parser to
rebuild the content of the node, but no scripts will be executed.  Any occuring
scripts can be dealt with in a manner analogous to the scripts on a loading
page.

\todo{Daniel: Don't really know what to say w.r.t. : execution contexts no problem (SVG and CSS uses native JavaScript)}
\todo{Jonas: Might not need to say anything. It is in relation to the other approaches 
which has to identify and rewrite all the contexts that can execute JS, since the 
extension replaces the JS engine for all contexts, you can't sneak code passed the monitor. Also relates to what you wrote about innerHTML.}

\paragraph{Integrity} The integrity of the method is guaranteed by virtue of
the fact that the JavaScript engine is turned off and all scripts are
interpreted by the monitor. Hence, the scripts are not active; rather, they are
passed as data to the monitor, and are only able to influence the execution
environment implemented by the monitor, and not the general execution
environment of the monitor itself.

\paragraph{Complete mediation}

Since all scripts are executed by the monitor complete mediation is inherited 
from the monitor.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{HTTP Proxy}

\begin{itemize}
\item- Proxy implemented in NodeJS
\item- rewrite all or nothing, problem with passing configuration to proxy
\item- DOM parsing to find scripts, compared to regular expressions
\item- difficult to identify all contexts (SVG, CSS and PDF can be rewritten, not flash)
\end{itemize}



\subsection{Web proxy (Service)}

\begin{itemize}
\item rewrite all or some, can pass configuration through cookie
\item piggybacking, wildcard DNS compared to URL parameter
\item SSL? wildcard certificates? features and drawbacks 
\item disable SOP, domain relaxing
\item DOM parsing to find scripts, compared to regular expressions
\item difficult to identify all contexts (SVG, CSS and PDF can be rewritten, not flash)
\end{itemize}


The web proxy was implemented in Node.js. 

There are different technical approaches to communicate the target URL to the web 
proxy. The URL can either be sent as a parameter of the request, 

The features of wildcard certificates is that the user can browse HTTPS pages. The drawback is that the user must fully trust that the monitor correctly verifies the signature of the page.

\todo{same origin policy between pages from different original domains loaded through the monitor can be relaxed to the origin of the proxy and share information freely}



\subsection{Integrator}

\begin{itemize}
\item- rewrite some, integrator driven, no or limited user configuration
\item- no need for parsing, integrator decides
\item- well defined per site policy
\item- site could allow user to configure policy
\item- requires developer understanding of the monitor
\item- future reflection of monitored code?
\end{itemize}


% 2-3 pages 
\section{Case study}
\label{sec:case}

\todo{Daniel: moved here - it's only here we talk about specifics}
\todo{Jonas: I think we should have a separate subsection here, describing the monitor and why/how it can be reused in all of the implementations}

In addition, while the
execution environment provided by different browsers are mostly standard
compliant there are small deviations. Such deviations must be reflected in 
the monitor, which, to a certain extend, makes the monitor browser specific.
One solution in to have the monitor detect its execution environment
and adapt accordingly. While possible, it is a big undertaking to support
a wide selection of (versions of) browsers.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo{Andrei: move to case studies}
\subsection{Shadowing}
\todo{Daniel: me must make sure to differentiate between the inlining ala older papers and the inlining we do here.}

Inline the monitor into the JavaScript code. Appealing idea, previous work for 
toy languages, but difficult in practice. Abandoned due to complexity with 
coercion in expressions.


\begin{itemize}
\item- mlcalc.com
\item- newyorker.com
\item- mockup vs. real deal
\end{itemize}

%1 page 
\section{Related work}
\label{sec:related}

Anderson~\cite{Anderson:72}

Erlingsson and Schneider~\cite{DBLP:conf/nspw/ErlingssonS99}

Language-based information-flow security encompasses a large body of
work, see an overview~\cite{Sabelfeld:Myers:JSAC}. We briefly
discuss inlining, followed by a consideration of most related work: on
formalizations of purely dynamic and hybrid monitors for information flow.

Inlined reference monitoring~\cite{Erlingsson:PhD04} is a mainstream
technique for enforcing safety properties. 
A prominent example in the context of the web is
BrowserShield~\cite{Reis+:TWeb07} that instruments scripts with
checks for known vulnerabilities.
The focus of this paper is on inlining for information-flow security. Information flow is not
a safety property~\cite{McLean:SSP94}, but can be approximated by
safety properties
(e.g.,~\cite{Boudol:FAST08,Sabelfeld:Russo:PSI09,Austin:Flanagan:PLAS09}),
just like it is approximated in this paper (see the remark at the end of Section~\ref{sec:intro}).

Chudnov and
Naumann~\cite{Chudnov:Naumann:CSF10} have investigated an inlining
approach to monitoring information flow. They inline a flow-sensitive
hybrid monitor by Russo and
Sabelfeld~\cite{Russo:Sabelfeld:CSF10}. The soundness of the inlined
monitor is ensured by bisimulation of the inlined monitor and the
original monitor.

Ligatti et al. \cite{Ligatti05editautomata:} present a 
general framework for security policies that can
be enforced by monitoring and modifying programs at runtime. 
They introduce \emph{edit automata} that enable
monitors to stop, suppress, and modify the behavior of programs. 

Magazinius et al.~\cite{DBLP:conf/nordsec/MagaziniusPS10}

Magazinius et al.~\cite{DBLP:journals/compsec/MagaziniusRS12}

Dam et al.~\cite{DBLP:conf/ecoop/DamJLP09,DBLP:journals/jcs/DamJLP10,DBLP:conf/ccs/DamGL12}

%1 page 
\section{Conclusions}
\label{sec:conc}

% Less than 4 pages 
\bibliographystyle{plain}
\bibliography{literature}
\end{document}
