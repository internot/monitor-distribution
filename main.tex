\documentclass{llncs}
%\documentclass[10pt, conference, compsocconf]{IEEEtran}

% From ESORICS'13 CFP
% Submitted papers should be at most 16 pages (using 10-point font), excluding 
% the bibliography and well-marked appendices, and at most 20 pages total.

\usepackage{listings}
\usepackage{url}

\usepackage{amssymb}
\usepackage[usenames]{color}
\definecolor{lightred}{rgb}{1,0.8,0.8}
\newcommand{\todo}[1]{\colorbox{red}{\textcolor{white}{\sffamily\bfseries\scriptsize TODO}} \textcolor{red}{#1} \textcolor{red}{$\blacktriangleleft$}}


\title{Architectures for Inlining Security Monitors in Web Applications}

\author{Jonas Magazinius \and Daniel Hedin \and Andrei Sabelfeld}
\institute{Chalmers University of Technology, Gothenburg, Sweden}
%%%%%%%%%%%%%%%% Schedule %%%%%%%%%%%%%%%%%%%%%%%%
\if 0
March 28 - paper shipped
March 27 - final polish
March 20 - mashup and case studies + intro and conclusions
March 13 - architecture and implementation done + related work
March 12 - implementation half-way
March 11 - architecture
\fi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}


\maketitle



\begin{abstract}
Securing JavaScript in the browser is an open and challenging
problem. Code from pervasive third-party JavaScript libraries exacerbates the
problem because it is executed with the same privileges as the code
that uses the libraries.
%
This paper focuses on securing JavaScript code by \emph{inlining}
security checks in the code before it is executed. We present
architectures for inlining security monitors for JavaScript: in
the browser, as an HTTP proxy, and as a web proxy (service). 
%
\todo{Jonas: The use of HTTP proxy/web proxy/suffix proxy is still under consideration (by me), and we'll need to discuss and update this to reflect that.}
%
These architectures offer great flexibility: they are parametric in the monitor itself,
and they provide freedom in the choice of where the monitor is
injected, allowing to serve the interests of users, code developers, code
integrators, and network administrators.
%
A key ingredient to open up for such flexibility is security monitoring in the form of a
security monitor for JavaScript, written itself in JavaScript.
%
Our case studies demonstrate successful deployment of a JavaScript
information-flow monitor with all three architectures.
\end{abstract}


% \begin{IEEEkeywords}
% Web Security; Polyglot; Injection; Cross-domain.
% \end{IEEEkeywords}








% 1-2 pages
\section{Introduction}
\label{sec:intro}

\todo{Daniel: I assume that we give a description on IF and monitors for IF in general in this section}

When introducing reference monitoring, Anderson~\cite{Anderson:72}
identifies the following requirements:
\begin{itemize}
\item \emph{monitor integrity}: the monitor must be tamperproof,
\item \emph{complete mediation}: the monitor must be always invoked, and
\item \emph{soundness}: the monitor must enforce the desired
  security policy.
\end{itemize}
In addition, requirements of \emph{conservativeness} and
\emph{transparency} are often in place for reference monitors to
ensure that no new behaviors are added or removed by monitors when the
original program is secure in the first place.

This paper proceeds as follows. Section~


% 1 pages
\section{Third-party code integration}
\label{sec:mash}

Describe mashups, difficulties in mashup security and information flows in mashups.

% 2-3 pages 
\section{Architecture}
\label{sec:arch}

This section presents the different architectures for inlining
security monitors. We motivate each architecture by scenarios of
intended usage and describe the details of the architectures.

\todo{Jonas: Nowhere do we actually discuss the monitor or its implementation}
\subsection{Monitor}
\label{sec:monitor}
The fact that the monitor is written in JavaScript unlocks a number of
different deployment options. In particular it allows the monitor to be run as
a browser extension, or as a part of the web page itself.  In this section we
give an overview of the different available approaches, and discuss their
relative strengths.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo{Andrei: move to case studies}
\subsection{Shadowing}
\todo{Daniel: me must make sure to differentiate between the inlining ala older papers and the inlining we do here.}

Inline the monitor into the JavaScript code. Appealing idea, previous work for 
toy languages, but difficult in practice. Abandoned due to complexity with 
coercion in expressions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo{Andrei: Motivating scenarios first}
\todo{Daniel: changed the name - plugins are things like Flash etc}
\subsection{Browser extension}
%
Modern browsers allow the functionality of the browser to be enriched via
\emph{extensions} typically written in JavaScript. This allows for the monitor
to be executed as part of an extension, which in turn allows for the use of the
monitor as the execution engine of web pages. The idea was pioneered by the
Zaphod \cite{Zaphod} extension for Firefox. Zaphod turns off the
standard JavaScript interpreter by disallowing JavaScript in the preferences
and listening to the appropriate page load event. Once the event is received the
page is traversed and all scripts are executed using the replacement engine,
e.g., the monitor. 

The main benefit of extensions is that once installed the engine is changed for
all pages without further interaction needed from the user. 
This deployment method gives the user direct control over what security
policies to enforce on the browsed pages.

\todo{Andrei: the following paragraph has two problems. First, it
  talks about information-flow control - but we want to stay general
  and only use information-flow control in examples. Second, of course
the monitor is a part of the TCB, which is true for all deployment
options. Why bring it up here?}
However, the
installation requirement is also the method's main disadvantage. Not only is
the extension browser specific and require the user to download, install and
setup the extension, it also requires the user to trust the monitor beyond
providing information flow control. In order to be able to enrich the
functionality of the browser the extensions run with the same privileges as the
browser. By allowing the monitor to run as part of an extension we allow it to
run with elevated privileges. Thus, we must trust the monitor not only to
provide information flow control, but not allow for the interpreted code to
exploit the privileges of the monitor. In the extension scenario, a breach of
the monitor puts more than the information-flow control at stake.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Web proxy}

\begin{itemize}
%\item- Practically the same monitor as the plugin
%\item- Browser independent
%\item- Less intrusive to the browser, simple proxy setup
%\item- Less cumbersome to setup
\item Server-side configuration? So far we have not discussed configuration.
%\item- General, every browsed page
\end{itemize}

A proxy specific to relaying HTTP requests is often referred to as a web proxy.
A web proxy is a convenient way to include the monitor in browsed pages without 
modifying the browser. The client configures the browser to relay 
all requests through the proxy, and the proxy rewrites the responses to include 
the monitor. The main benefits of a web proxy compared to a browser 
extension are that it requires 
minimal configuration to set up and does not intrude in the browser. However, there 
are certain drawbacks as well. 
%
As an example, any JavaScript code executed outside of the monitor can affect 
the monitor state. Therefore, in order to protect the integrity of the monitor, all 
script code in a page must be executed within the monitor. Whereas a 
browser extension captures execution of all scripts by replacing the JavaScript 
engine of the browser, a web proxy must identify all contexts in which JavaScript 
can be executed and rewrite them to direct execution to the monitor.

The design of the monitor allows us to reuse the monitor code used in the 
browser extension, with barely any modifications. The modifications required 
are again related to execution contexts. Various browser features, such as 
\emph{document.write} and \emph{innerHTML}, allow an arbitrary string to be 
interpreted and rendered as HTML. Any scripts present in the string will be 
executed upon interpretation. The monitor must account for this and rewrite 
the string to direct execution to the monitor.

A web proxy in itself is browser independent, but as it relies on the monitor, 
this is difficult to achieve in practice, as discussed in Section~\ref{sec:monitor}.
\todo{Jonas: Need to actually discuss why it is difficult to make the monitor browser independent in the new section about the monitor}


\paragraph{Suffix proxy}
\todo{Jonas: Just found out that the "service" we developed is actually a suffix proxy, which actually could have been implemented in a simpler way using .htaccess request rewriting. Also found a way to redirect all ports to a single port using iptables. Perfect solution.}
\begin{itemize}
%\item What is a web proxy
%\item How can a web proxy help in distributing the monitor
%\item 
%\item Delivering the associated cookies?
%\item Same-origin policy in respect to different design choices
%\item More intrusive in HTML content, rewrite links and external references 
%\item Browser independent? Depends on the monitor
%\item Not intrusive to the browser
%\item Even less cumbersome to setup, browse to server URL
\item Server-side and client-side configuration possible?
%\item Less general, only browsed pages
\end{itemize}


A \emph{suffix proxy} is special kind of web proxy that makes use of DNS wildcards to 
relay requests, instead of the usual practice of configuring the browser.
To direct the request to the proxy, the user appends the domain name of the 
proxy to the target domain. The suffix proxy is set up such
that all requests to any sub-domain of the proxy domain is directed to the proxy domain, 
e.g. in DNS terms \emph{*.proxy.domain}. 

There are several differences between a suffix proxy compared to a traditional 
web proxy. A suffix proxy lets the user decide which pages to proxy on a 
per-domain basis, making it less general than a traditional proxy that covers 
all requests. To accomplish this the domain of the original URL is modified.
The consequence is twofold; the original URL and the modified URL are no longer 
considered the same origin, and the domain of the proxy needs to 
be inlined in all external requests. The first implies that all origin specific 
information associated with the original domain, e.g. cookies and local storage, 
are no longer associated with the modified domain, and vice versa. 


\todo{same origin policy between pages from different original domains loaded through the monitor can be relaxed to the origin of the proxy and share information freely}





The latter implies that apart from rewriting scripts within a page, all URLs to external resources, i.e., to origins outside the scope of the original origin, must be rewritten to include the domain of the proxy. This ensures that all resources associated with the page are loaded through the proxy.

Also, it does not require any configuration and leaves the browser 
completely unchanged.

\todo{Jonas: The following could be part of a scenario but does not fit well here \\
Typically, the user navigates to the web application and enters the URL in 
an input field. The URL is then sent to the server which in turn makes the request to the 
target URL. To simplify further 
browsing, the response is rewritten to inline the URL of the web proxy 
into all outgoing references on the retrieved page; this way, when the user 
follows a link on the page, the request will again be relayed the web proxy. 
The modified response is returned to the user. Rewriting makes the method more 
intrusive to the HTML content, but less intrusive to the users browser.
}

\subsection{Integrator}

The mashup integrator includes the monitor and decides which JavaScript should 
run within the monitor. (Don't mention sandbox.) You're done.
\begin{itemize}
\item- No setup
\item- Not intrusive to the browser
\item- Not general
\item- Deliberately intrusive to HTML
\item- Integrator configuration, no user control
\item- Run independent part of the code outside the monitor, possible performance gains
\end{itemize}


% 4 pages 
\section{Implementation}
\label{sec:impl}

%Describe features and drawbacks with each implementation.
For each deployment option, we first describe how it is implemented,
discuss the relative pros and cons, and show how the integrity of the monitor
and complete mediation are achieved.

% Implementation details
\subsection{Monitor}
\todo{Jonas: I think we should have a separate subsection here, describing the monitor and why/how it can be reused in all of the implementations}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Browser extension}
\todo{Do we need to mention JSFlow here? The idea is to focus on how
  the monitor is injected in this deployment, and not to describe the
  monitor itself.}
%
\todo{Daniel: Some reiteration here, but I don't see a way around it} The
monitor we make use of in this work is JSFlow~\cite{JSFLow}. JSFlow is bundled
together with a Firefox extension based on Zaphod~\cite{Zaphod}. The extension
works by turning off the standard execution engine for JavaScript, and hooking
itself to the appropriate page events. We have resolved a number of challenges
pertaining to the implementation of the extension.

\paragraph{Execution time}

When web pages are loaded, the scripts of the pages are executed as they are
encountered while parsing the web page. This means that the DOM tree of the
page might not have been fully constructed when the scripts execute.  For
scripts that interact with the DOM tree this is important, in particular if the
script injects nodes into the tree. The consequence of this is that it is not
entirely satisfactory to listen to the \emph{DOMContentLoaded} event and
thereafter traverse the fully parsed DOM tree looking for scripts to execute.
Rather, we need to receive events precisely when the scripts are added to the
DOM tree during the parsing process. This can be be achieved with DOM
MutationEvents. However, the DOM MutationEvents are deprecated due to
efficiency issues and are going to be replaced with a notion of
MutationObserver.  If the replacement notion can be used to execute scripts at
the time of addition to the DOM tree remains an open question due to event
grouping, i.e., when the mutation observer receives a collection of events
bundled together for performance reasons. 


\paragraph{document.write} The problem of execution time is particularly
prominent for scripts using \emph{document.write}. The semantics of
\emph{document.write} is loosely specified saying that \emph{document.write}
writes into a string into the current position of the document.  Intuitively,
\emph{document.write} writes into the character stream that is fed to the HTML
parser, which, for obvious reason can have drastic effects on the parsing of
the page.  However, in Firefox there is a bigger obstacle for
\emph{document.write}. For security reasons \emph{document.write} is not
allowed to be executed from the extension context.  Hence, an extension cannot
easily provide the full functionality of \emph{document.write}.  Thankfully,
few web pages make use of the full functionality of \emph{document.write} ---
it is mostly used to inject scripts into the page while the page is loading. It
is fairly easy to identify such use of \emph{document.write} and provide
support for this use.


\paragraph{Browser specifics}

\todo{Daniel: this is actually true regardless of deployment method - should we be more open with that?}

\todo{Jonas: Yes, I think so. This is a challenge of the monitor itself and it would make sense to move it to a general section about the monitor we use.}

Browser extensions are inherently browser specific. In addition, while the
execution environment provided by different browsers are mostly standard
compliant there are small deviations. Such deviations must be reflected in 
the monitor, which, to a certain extend, makes the monitor browser specific.
One solution in to have the monitor detect its execution environment
and adapt accordingly. While possible, it is a big undertaking to support
a wide selection of (versions of) browsers.


On the positive side it should be mentioned that otherwise challenging features
like \emph{innerHTML} are essentially for free for extension based deployment.

\todo{Daniel: crosslink with other deployment methods?} \paragraph{innerHTML}
%
\emph{innerHTML} is a property on all DOM nodes which allows the text
representation of the node to be changed. Any change of the \emph{innerHTML}
property causes the content of the node to be changed by parsing the changed
property. For other deployment methods this means that the value written to
\emph{innerHTML} must be validated, and possibly changed before the write is
allowed to occur.  For the extension based deployment this is not the case.
Since the standard JavaScript execution engine is turned off it is safe to
write to the \emph{innerHTML} property. The write will trigger the parser to
rebuild the content of the node, but no scripts will be executed.  Any occuring
scripts can be dealt with in a manner analogous to the scripts on a loading
page.

\todo{Daniel: Don't really know what to say w.r.t. : execution contexts no problem (SVG and CSS uses native JavaScript)}
\todo{Jonas: Might not need to say anything. It is in relation to the other approaches 
which has to identify and rewrite all the contexts that can execute JS, since the 
extension replaces the JS engine for all contexts, you can't sneak code passed the monitor. Also relates to what you wrote about innerHTML.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{HTTP Proxy}

\begin{itemize}
\item- Proxy implemented in NodeJS
\item- rewrite all or nothing, problem with passing configuration to proxy
\item- DOM parsing to find scripts, compared to regular expressions
\item- difficult to identify all contexts (SVG, CSS and PDF can be rewritten, not flash)
\end{itemize}



\subsection{Web proxy (Service)}

\begin{itemize}
\item rewrite all or some, can pass configuration through cookie
\item piggybacking, wildcard DNS compared to URL parameter
\item SSL? wildcard certificates? features and drawbacks 
\item disable SOP, domain relaxing
\item DOM parsing to find scripts, compared to regular expressions
\item difficult to identify all contexts (SVG, CSS and PDF can be rewritten, not flash)
\end{itemize}


The web proxy was implemented in Node.js. 

There are different technical approaches to communicate the target URL to the web 
proxy. The URL can either be sent as a parameter of the request, 

The features of wildcard certificates is that the user can browse HTTPS pages. The drawback is that the user must fully trust that the monitor correctly verifies the signature of the page.

\subsection{Integrator}

\begin{itemize}
\item- rewrite some, integrator driven, no or limited user configuration
\item- no need for parsing, integrator decides
\item- well defined per site policy
\item- site could allow user to configure policy
\item- requires developer understanding of the monitor
\item- future reflection of monitored code?
\end{itemize}


% 2-3 pages 
\section{Case study}
\label{sec:case}

\begin{itemize}
\item- mlcalc.com
\item- newyorker.com
\item- mockup vs. real deal
\end{itemize}

%1 page 
\section{Related work}
\label{sec:related}

Anderson~\cite{Anderson:72}

Erlingsson and Schneider~\cite{DBLP:conf/nspw/ErlingssonS99}

Language-based information-flow security encompasses a large body of
work, see an overview~\cite{Sabelfeld:Myers:JSAC}. We briefly
discuss inlining, followed by a consideration of most related work: on
formalizations of purely dynamic and hybrid monitors for information flow.

Inlined reference monitoring~\cite{Erlingsson:PhD04} is a mainstream
technique for enforcing safety properties. 
A prominent example in the context of the web is
BrowserShield~\cite{Reis+:TWeb07} that instruments scripts with
checks for known vulnerabilities.
The focus of this paper is on inlining for information-flow security. Information flow is not
a safety property~\cite{McLean:SSP94}, but can be approximated by
safety properties
(e.g.,~\cite{Boudol:FAST08,Sabelfeld:Russo:PSI09,Austin:Flanagan:PLAS09}),
just like it is approximated in this paper (see the remark at the end of Section~\ref{sec:intro}).

Chudnov and
Naumann~\cite{Chudnov:Naumann:CSF10} have investigated an inlining
approach to monitoring information flow. They inline a flow-sensitive
hybrid monitor by Russo and
Sabelfeld~\cite{Russo:Sabelfeld:CSF10}. The soundness of the inlined
monitor is ensured by bisimulation of the inlined monitor and the
original monitor.

Ligatti et al. \cite{Ligatti05editautomata:} present a 
general framework for security policies that can
be enforced by monitoring and modifying programs at runtime. 
They introduce \emph{edit automata} that enable
monitors to stop, suppress, and modify the behavior of programs. 

Magazinius et al.~\cite{DBLP:conf/nordsec/MagaziniusPS10}

Magazinius et al.~\cite{DBLP:journals/compsec/MagaziniusRS12}

Dam et al.~\cite{DBLP:conf/ecoop/DamJLP09,DBLP:journals/jcs/DamJLP10,DBLP:conf/ccs/DamGL12}

%1 page 
\section{Conclusions}
\label{sec:conc}

% Less than 4 pages 
\bibliographystyle{plain}
\bibliography{literature}
\end{document}
