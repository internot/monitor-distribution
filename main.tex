\documentclass{llncs}
%\documentclass[10pt, conference, compsocconf]{IEEEtran}

% From ESORICS'13 CFP
% Submitted papers should be at most 16 pages (using 10-point font), excluding 
% the bibliography and well-marked appendices, and at most 20 pages total.

\usepackage{listings}
\usepackage{url}

\usepackage{amssymb}
\usepackage[usenames]{color}
\definecolor{lightred}{rgb}{1,0.8,0.8}
\newcommand{\todo}[1]{\colorbox{red}{\textcolor{white}{\sffamily\bfseries\scriptsize TODO}} \textcolor{red}{#1} \textcolor{red}{$\blacktriangleleft$}}


\title{Architectures for Inlining Information-Flow Monitors in Web Applications}

%%%%%%%%%%%%%%%% Schedule %%%%%%%%%%%%%%%%%%%%%%%%
\if 0
March 28 - paper shipped
March 27 - final polish
March 20 - mashup and case studies + intro and conclusions
March 13 - architecture and implementation done + related work
March 6 - most implementation done
\fi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}


\maketitle



\begin{abstract}
Various implementations of ways to distribute a monitor to the clients.
\end{abstract}


% \begin{IEEEkeywords}
% Web Security; Polyglot; Injection; Cross-domain.
% \end{IEEEkeywords}








% 1-2 pages
\section{Introduction}
\label{sec:intro}

\todo{Daniel: I assume that we give a description on IF and monitors for IF in general in this section}

% 1 pages
\section{Mashups}
\label{sec:mash}

Describe mashups, difficulties in mashup security and information flows in mashups.

% 2-3 pages 
\section{Architecture}
\label{sec:arch}

\todo{Jonas: Nowhere do we actually discuss the monitor or its implementation}

The fact that the monitor is written in JavaScript unlocks a number of
different deployment options. In particular it allows the monitor to be run as
a browser extension, or as a part of the web page itself.  In this section we
give an overview of the different available approaches, and discuss their
relative strengths.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Shadowing}
\todo{Daniel: me must make sure to differentiate between the inlining ala older papers and the inlining we do here.}

Inline the monitor into the JavaScript code. Appealing idea, previous work for 
toy languages, but difficult in practice. Abandoned due to complexity with 
coercion in expressions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo{Daniel: changed the name - plugins are things like Flash etc}
\subsection{Browser extension}
%
Modern browsers allow the functionality of the browser to be enriched via
\emph{extensions} typically written in JavaScript. This allows for the monitor
to be executed as part of an extension, which in turn allows for the use of the
monitor as the execution engine of web pages. The idea was pioneered by the
Zaphod\cite{Zaphod} extension for Firefox.  The basic idea is to turn of the
standard JavaScript interpreter by disallowing JavaScript in the preferences
and listen to the appropriate page load event. Once the event is received the
page is traversed and all scripts are executed using the replacement engine,
e.g., the monitor. 

The main benefit of extensions is that once installed the engine is changed for
all pages without further interaction needed from the user. However, the
installation requirement is also the method's main disadvantage. Not only is
the extension browser specific and require the user to download, install and
setup the extension, it also requires the user to trust the monitor beyond
providing information flow control. In order to be able to enrich the
functionality of the browser the extensions run with the same privileges as the
browser. By allowing the monitor to run as part of an extension we allow it to
run with elevated privileges. Thus, we must trust the monitor not only to
provide information flow control, but not allow for the interpreted code to
exploit the privileges of the monitor. In the extension scenario, a breach of
the monitor puts more than the information flow control at stake.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{HTTP proxy}

Proxy injects monitor into every page and wraps all JavaScript. Setup the proxy 
and you're done.
\begin{itemize}
\item- Practically the same monitor as the plugin
\item- Browser independent
\item- Less intrusive to the browser, simple proxy setup
\item- Less cumbersome to setup
\item- Server-side configuration
\item- General, every browsed page
\end{itemize}

\subsection{Web proxy}

Service injects browsed pages with the monitor and references to itself, and 
wraps all JavaScript. Browse through service and you're done.
\begin{itemize}
\item- More intrusive in HTML content, rewrite links and external references 
\item- Browser independent
\item- Not intrusive to the browser
\item- Even less cumbersome to setup, browse to server URL
\item- Server-side and client-side configuration possible
\item- Less general, only browsed pages
\end{itemize}


A \emph{web proxy} is essentially a web application that allow a user to relay requests, 
through the web application, to other web pages. The difference compared to an 
HTTP proxy is that it does not require the user to configure the browser to use a 
proxy. Typically, the user navigates to the web application and enters the URL in 
an input field. The URL is then sent to the server which in turn makes the request to the 
target URL. To simplify further 
browsing, the response is rewritten to inline the URL of the web proxy 
into all outgoing references on the retrieved page; this way, when the user 
follows a link on the page, the request will again be relayed the web proxy. 
The modified response is returned to the user. 
There are multiple ways a web proxy can be designed, and each design choice 
has its benefits and drawbacks, especially with respect to the same origin policy.

\paragraph{Target URL}

\subsection{Integrator}

The mashup integrator includes the monitor and decides which JavaScript should 
run within the monitor. (Don't mention sandbox.) You're done.
\begin{itemize}
\item- No setup
\item- Not intrusive to the browser
\item- Not general
\item- Deliberately intrusive to HTML
\item- Integrator configuration, no user control
\item- Run independent part of the code outside the monitor, possible performance gains
\end{itemize}


% 4 pages 
\section{Implementation}
\label{sec:impl}

Describe features and drawbacks with each implementation.

% Implementation details
\subsection{Monitor}
\todo{Jonas: I think we should have a separate subsection here, describing the monitor and why/how it can be reused in all of the implementations}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Browser extension}
%
\todo{Daniel: Some reiteration here, but I don't see a way around it} The
monitor we make use of in this work is JSFlow~\cite{}. JSFlow is bundled
together with a Firefox extension based on Zaphod~\cite{Zaphod}. The extension
works by turning off the standard execution engine for JavaScript, and hooking
itself to the appropriate page events. There are a number of challenges
pertaining to the implementation of the extension.

\paragraph{Execution time}

When web pages are loaded, the scripts of the pages are executed as they are
encountered while parsing the web page. This means that the DOM tree of the
page might not have been fully constructed when the scripts execute.  For
scripts that interact with the DOM tree this is important, in particular if the
script injects nodes into the tree. The consequence of this is that it is not
entirely satisfactory to listen to the \emph{DOMContentLoaded} event and
thereafter traverse the fully parsed DOM tree looking for scripts to execute.
Rather, we need to receive events precisely when the scripts are added to the
DOM tree during the parsing process. This can be be achieved with DOM
MutationEvents. However, the DOM MutationEvents are deprecated due to
efficiency issues and are going to be replaced with a notion of
MutationObserver.  If the replacement notion can be used to execute scripts at
the time of addition to the DOM tree remains an open question due to event
grouping, i.e., when the mutation observer receives a collection of events
bundled together for performance reasons. 


\paragraph{document.write} The problem of execution time is particularly
prominent for scripts using \emph{document.write}. The semantics of
\emph{document.write} is loosely specified saying that \emph{document.write}
writes into a string into the current position of the document.  Intuitively,
\emph{document.write} writes into the character stream that is fed to the HTML
parser, which, for obvious reason can have drastic effects on the parsing of
the page.  However, in Firefox there is a bigger obstacle for
\emph{document.write}. For security reasons \emph{document.write} is not
allowed to be executed from the extension context.  Hence, an extension cannot
easily provide the full functionality of \emph{document.write}.  Thankfully,
few web pages make use of the full functionality of \emph{document.write} ---
it is mostly used to inject scripts into the page while the page is loading. It
is fairly easy to identify such use of \emph{document.write} and provide
support for this use.


\paragraph{Browser specifics}

\todo{Daniel: this is actually true regardless of deployment method - should we be more open with that?}

Browser extensions are inherently browser specific. In addition, while the
execution environment provided by different browsers are mostly standard
compliant there are small deviations. Such deviations must be reflected in 
the monitor, which, to a certain extend, makes the monitor browser specific.
One solution in to have the monitor detect its execution environment
and adapt accordingly. While possible, it is a big undertaking to support
a wide selection of (versions of) browsers.


On the positive side it should be mentioned that otherwise challenging features
like \emph{innerHTML} are essentially for free for extension based deployment.

\todo{Daniel: crosslink with other deployment methods?} \paragraph{innerHTML}
%
\emph{innerHTML} is a property on all DOM nodes which allows the text
representation of the node to be changed. Any change of the \emph{innerHTML}
property causes the content of the node to be changed by parsing the changed
property. For other deployment methods this means that the value written to
\emph{innerHTML} must be validated, and possibly changed before the write is
allowed to occur.  For the extension based deployment this is not the case.
Since the standard JavaScript execution engine is turned off it is safe to
write to the \emph{innerHTML} property. The write will trigger the parser to
rebuild the content of the node, but no scripts will be executed.  Any occuring
scripts can be dealt with in a manner analogous to the scripts on a loading
page.

\todo{Daniel: Don't really know what to say w.r.t. : execution contexts no problem (SVG and CSS uses native JavaScript)}
\todo{Jonas: Might not need to say anything. It is in relation to the other approaches which has to identify and rewrite all the contexts that can execute JS, so that you can't sneak code passed the monitor.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{HTTP Proxy}

\begin{itemize}
\item- Proxy implemented in NodeJS
\item- rewrite all or nothing, problem with passing configuration to proxy
\item- DOM parsing to find scripts, compared to regular expressions
\item- difficult to identify all contexts (SVG, CSS and PDF can be rewritten, not flash)
\end{itemize}



\subsection{Web proxy (Service)}

\begin{itemize}
\item What is a web proxy
\item How can a web proxy help in distributing the monitor
\item 
\item Delivering the associated cookies
\item Same-origin policy in respect to different design choices
\item rewrite all or some, can pass configuration through cookie
\item piggybacking, wildcard DNS compared to URL parameter
\item disable SOP, domain relaxing
\item DOM parsing to find scripts, compared to regular expressions
\item difficult to identify all contexts (SVG, CSS and PDF can be rewritten, not flash)
\end{itemize}


The web proxy was implemented in Node.js. 

There are different technical approaches to communicate the target URL to the web 
proxy. The URL can either be sent as a parameter of the request, 

\subsection{Integrator}

\begin{itemize}
\item- rewrite some, integrator driven, no or limited user configuration
\item- no need for parsing, integrator decides
\item- well defined per site policy
\item- site could allow user to configure policy
\item- requires developer understanding of the monitor
\item- future reflection of monitored code?
\end{itemize}


% 2-3 pages 
\section{Case study}
\label{sec:case}

\begin{itemize}
\item- mlcalc.com
\item- newyorker.com
\item- mockup vs. real deal
\end{itemize}

%1 page 
\section{Related work}
\label{sec:related}

Inlining Erlingsson-Schneider 1990.

%1 page 
\section{Conclusions}
\label{sec:conc}

% Less than 4 pages 
\bibliographystyle{plain}
\bibliography{literature}
\end{document}
